---
layout: page
---

<h2>Weighting Pairs of Rows</h2>

<h3>The Original Version</h3>

<p>In computing the APC, we assign weights to pairs of observations. Taking \(v\) (the inputs not of interest) from the first element of the pair, \(u_1\) from the first element of the pair, and \(u_2\) from the second element of the pair, these samples and their weights are meant to approximate the distribution with density \(p(v)p(u_1|v)p(u_2|v)\).</p>

<p>If we had many observations for each unique value of \(v\), this would be easy: We&#39;d just assign weight 1 to the pairs that share the same value of \(v\), and weight 0 to the other pairs. In reality, we achieve something like this by assigning more weight to closer pairs.</p>

<p>The suggestion in <a href="http://onlinelibrary.wiley.com/doi/10.1111/j.1467-9531.2007.00181.x/abstract">Gelman and Pardoe 2007</a> is to consider all pairs of rows from the original data set and use weights based on the Mahalanobis distance \(d\) between the corresponding \(v\), such as \[\frac{1}{1 + d}.\]</p>

<h3>Need for Renormalizing Weights</h3>

<p>Pairs of rows with nearby \(v\)&#39;s have high weights, where pairs from far-away \(v\)&#39;s have low weights. But rows with fewer \(v\)&#39;s near them end up with less total weight than rows with more \(v\)&#39;s near them. This isn&#39;t so good, since we meant to weight \(v\)&#39;s according to their distribution in the original data set.</p>

<p>The solution is to renormalize the weights so that when grouping by the first element of each pair, the sum for each group is the same. Here&#39;s <a href="https://github.com/dchudz/predcomps/blob/master/R/pairs.R#L85">the line of code that does this in the package</a>.</p>

<p>Maybe this renormalization goes without saying, but it isn&#39;t explicitly mentioned in <a href="http://onlinelibrary.wiley.com/doi/10.1111/j.1467-9531.2007.00181.x/abstract">Gelman and Pardoe 2007</a>.</p>

<h3>Far Away Points Dominate</h3>

<p>Imagine \(v\) is a vector of \(n\) inputs, spread uniformly throughout space. Then the expected number of points at distance \(d\) from a given \(v\) would be proportional to \(d^n\). This means that using weights inversely proportional to distance will end up letting far-away points dominate, once you account for how many more far-away points there are. </p>

<h3>Current Implementation: Using a Fixed Number of Nearest Points</h3>

<p>My current implementation allows you an option that addresses the above concern that far-away points dominate (in an unfortunately ad hoc manner): You can specify that for each transition start point, we keep only certain number of the nearest transition end points. This parameter is specified as <code>onlyIncludeNearestN</code>.</p>

<p>The appropriate setting for this parameter will depend on the number of points used, and maybe other properties of the data set.</p>

<h3>Limiting the number of points used</h3>

<p>In the paper, Gelman and Pardoe mention that we can save on computation by, when necessary, estimating the average predictive comparison using a subset of the available data. My suggestion is that the set of points considered for transition starts need not be the same as the set considered for transition ends. For example, we choose a small subset as candidate transition starts, we may still wish to consider the full data set as potential endpoints for the transitions. This could be beneficial, since to best represent the conditional distribution \(p(u_2|v_1)\) we&#39;re looking for \(v_2\) close to \(v_1\). We will find a closer \(v_2\) by considering a larger set of potential transition endpoints than if we restricted the set of candidates for \(v_2\) just as we restricted for \(v_1\).</p>

<p>The parameters to specify are <code>numForTransitionStart</code> and <code>numForTransitionEnd</code>. They default to <code>NULL</code>, in which case we use the entire data set. </p>

<h3>Recommendations</h3>

<p>I recommend that <code>numForTransitionEnd</code> should be larger than <code>numForTransitionStart</code>, and that <code>onlyIncludeNearestN</code> should be a fraction of <code>numForTransitionEnd</code>.</p>

<p>However, appropriate settings are not well understand. Please send me your feedback on what works well for you.</p>

